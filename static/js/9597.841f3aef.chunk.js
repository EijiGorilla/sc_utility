"use strict";(self.webpackChunksc_utility=self.webpackChunksc_utility||[]).push([[9597],{78084:(e,t,i)=>{i.d(t,{Z:()=>h});var a,n=i(93169),s=i(13005);!function(e){e[e.varint=0]="varint",e[e.fixed64=1]="fixed64",e[e.delimited=2]="delimited",e[e.fixed32=5]="fixed32",e[e.unknown=99]="unknown"}(a||(a={}));const r=4294967296,o=new TextDecoder("utf-8"),l=(0,n.Z)("safari")||(0,n.Z)("ios")?6:(0,n.Z)("ff")?12:32;class h{constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e?e.byteLength:0;this._tag=0,this._dataType=a.unknown,this._init(e,t,i,n)}_init(e,t,i,a){this._data=e,this._dataView=t,this._pos=i,this._end=a}asUnsafe(){return this}clone(){return new h(this._data,this._dataView,this._pos,this._end)}pos(){return this._pos}move(e){this._pos=e}nextTag(e){for(;;){if(this._pos===this._end)return!1;const t=this._decodeVarint();if(this._tag=t>>3,this._dataType=7&t,!e||e===this._tag)break;this.skip()}return!0}next(){if(this._pos===this._end)return!1;const e=this._decodeVarint();return this._tag=e>>3,this._dataType=7&e,!0}empty(){return this._pos>=this._end}tag(){return this._tag}getInt32(){return this._decodeVarint()}getInt64(){return this._decodeVarint()}getUInt32(){let e=4294967295;if(e=(127&this._data[this._pos])>>>0,this._data[this._pos++]<128)return e;if(e=(e|(127&this._data[this._pos])<<7)>>>0,this._data[this._pos++]<128)return e;if(e=(e|(127&this._data[this._pos])<<14)>>>0,this._data[this._pos++]<128)return e;if(e=(e|(127&this._data[this._pos])<<21)>>>0,this._data[this._pos++]<128)return e;if(e=(e|(15&this._data[this._pos])<<28)>>>0,this._data[this._pos++]<128)return e;throw new Error("Varint overflow")}getUInt64(){return this._decodeVarint()}getSInt32(){const e=this.getUInt32();return e>>>1^-(1&e)}getSInt64(){return this._decodeSVarint()}getBool(){const e=0!==this._data[this._pos];return this._skip(1),e}getEnum(){return this._decodeVarint()}getFixed64(){const e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+e.getUint32(t+4,!0)*r;return this._skip(8),i}getSFixed64(){const e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+e.getInt32(t+4,!0)*r;return this._skip(8),i}getDouble(){const e=this._dataView.getFloat64(this._pos,!0);return this._skip(8),e}getFixed32(){const e=this._dataView.getUint32(this._pos,!0);return this._skip(4),e}getSFixed32(){const e=this._dataView.getInt32(this._pos,!0);return this._skip(4),e}getFloat(){const e=this._dataView.getFloat32(this._pos,!0);return this._skip(4),e}getString(){const e=this._getLength(),t=this._pos,i=this._toString(this._data,t,t+e);return this._skip(e),i}getBytes(){const e=this._getLength(),t=this._pos,i=this._toBytes(this._data,t,t+e);return this._skip(e),i}getLength(){return this._getLengthUnsafe()}processMessageWithArgs(e,t,i,a){const n=this.getMessage(),s=e(n,t,i,a);return n.release(),s}processMessage(e){const t=this.getMessage(),i=e(t);return t.release(),i}getMessage(){const e=this._getLength(),t=h.pool.acquire();return t._init(this._data,this._dataView,this._pos,this._pos+e),this._skip(e),t}release(){h.pool.release(this)}dataType(){return this._dataType}skip(){switch(this._dataType){case a.varint:this._decodeVarint();break;case a.fixed64:this._skip(8);break;case a.delimited:this._skip(this._getLength());break;case a.fixed32:this._skip(4);break;default:throw new Error("Invalid data type!")}}skipLen(e){this._skip(e)}_skip(e){if(this._pos+e>this._end)throw new Error("Attempt to skip past the end of buffer!");this._pos+=e}_decodeVarint(){const e=this._data;let t=this._pos,i=0,a=0;if(this._end-t>=10)do{if(a=e[t++],i|=127&a,!(128&a))break;if(a=e[t++],i|=(127&a)<<7,!(128&a))break;if(a=e[t++],i|=(127&a)<<14,!(128&a))break;if(a=e[t++],i|=(127&a)<<21,!(128&a))break;if(a=e[t++],i+=268435456*(127&a),!(128&a))break;if(a=e[t++],i+=34359738368*(127&a),!(128&a))break;if(a=e[t++],i+=4398046511104*(127&a),!(128&a))break;if(a=e[t++],i+=562949953421312*(127&a),!(128&a))break;if(a=e[t++],i+=72057594037927940*(127&a),!(128&a))break;if(a=e[t++],i+=0x8000000000000000*(127&a),!(128&a))break;throw new Error("Varint too long!")}while(0);else{let n=1;for(;t!==this._end&&(a=e[t],128&a);)++t,i+=(127&a)*n,n*=128;if(t===this._end)throw new Error("Varint overrun!");++t,i+=a*n}return this._pos=t,i}_decodeSVarint(){const e=this._data;let t,i=0,a=0;const n=1&e[this._pos];if(a=e[this._pos++],i|=127&a,!(128&a))return n?-(i+1)/2:i/2;if(a=e[this._pos++],i|=(127&a)<<7,!(128&a))return n?-(i+1)/2:i/2;if(a=e[this._pos++],i|=(127&a)<<14,!(128&a))return n?-(i+1)/2:i/2;if(a=e[this._pos++],i|=(127&a)<<21,!(128&a))return n?-(i+1)/2:i/2;if(a=e[this._pos++],i+=268435456*(127&a),!(128&a))return n?-(i+1)/2:i/2;if(a=e[this._pos++],i+=34359738368*(127&a),!(128&a))return n?-(i+1)/2:i/2;if(a=e[this._pos++],i+=4398046511104*(127&a),!(128&a))return n?-(i+1)/2:i/2;if(t=BigInt(i),a=e[this._pos++],t+=0x2000000000000n*BigInt(127&a),!(128&a))return Number(n?-(t+1n)/2n:t/2n);if(a=e[this._pos++],t+=0x100000000000000n*BigInt(127&a),!(128&a))return Number(n?-(t+1n)/2n:t/2n);if(a=e[this._pos++],t+=0x8000000000000000n*BigInt(127&a),!(128&a))return Number(n?-(t+1n)/2n:t/2n);throw new Error("Varint too long!")}_getLength(){if(this._dataType!==a.delimited)throw new Error("Not a delimited data type!");return this._decodeVarint()}_getLengthUnsafe(){return this.getUInt32()}_toString(e,t,i){if((i=Math.min(this._end,i))-t>l){const a=e.subarray(t,i);return o.decode(a)}let a="",n="";for(let s=t;s<i;++s){const t=e[s];128&t?n+="%"+t.toString(16):(a+=decodeURIComponent(n)+String.fromCharCode(t),n="")}return n.length&&(a+=decodeURIComponent(n)),a}_toBytes(e,t,i){return i=Math.min(this._end,i),new Uint8Array(e.buffer,t,i-t)}}h.pool=new s.Z(h,void 0,(e=>{e._data=null,e._dataView=null}))},51750:(e,t,i)=>{i.d(t,{Lr:()=>n,v3:()=>a});const a=15.5,n=1024},12233:(e,t,i)=>{i.d(t,{Z:()=>a});class a{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.x=e,this.y=t,this.width=i,this.height=a}get isEmpty(){return this.width<=0||this.height<=0}union(e){this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.width=Math.max(this.width,e.width),this.height=Math.max(this.height,e.height)}}},94109:(e,t,i)=>{i.d(t,{A5:()=>g,IZ:()=>o,JS:()=>p,KA:()=>_,NT:()=>m,Vo:()=>u,_8:()=>f,_E:()=>c,dD:()=>h,do:()=>l,i9:()=>a,iD:()=>s,s4:()=>d,uk:()=>n,wi:()=>r});const a=512,n=29,s=24;var r;!function(e){e[e.FilterFlags=0]="FilterFlags",e[e.Animation=1]="Animation",e[e.GPGPU=2]="GPGPU",e[e.VV=3]="VV",e[e.DD0=4]="DD0",e[e.DD1=5]="DD1",e[e.DD2=6]="DD2",e[e.LocalTimeOrigin=7]="LocalTimeOrigin"}(r||(r={}));const o=6,l=1.05,h=5,c=6,u=1.15,d=2,p=10,_=1024,f=256,g=32,m=512},42069:(e,t,i)=>{i.d(t,{A:()=>c});var a=i(27366),n=i(42537),s=i(66978),r=i(94172),o=i(49861),l=(i(93169),i(32718),i(84936),i(69912)),h=i(5354);const c=e=>{let t=class extends e{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(){super.postscript(),(0,h.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}async _validateHeightModelInfo(){const e=new AbortController,t=e.signal;this.addHandles((0,n.kB)((()=>e.abort()))),await(0,r.N1)((()=>this.view.defaultsFromMap?.heightModelInfoReady),t),(0,s.k_)(t);const i=(0,h.Wt)(this.layer,this.view.heightModelInfo,this.supportsHeightUnitConversion);if(i)throw i}};return(0,a._)([(0,o.Cb)()],t.prototype,"view",void 0),(0,a._)([(0,o.Cb)()],t.prototype,"slicePlaneEnabled",void 0),t=(0,a._)([(0,l.j)("esri.views.3d.layers.LayerView3D")],t),t}},77385:(e,t,i)=>{i.d(t,{r:()=>d});var a=i(27366),n=i(10064),s=i(94172),r=i(49861),o=(i(93169),i(32718),i(84936),i(69912)),l=i(20488),h=i(58890),c=i(53379),u=i(69787);const d=e=>{let t=class extends e{constructor(){super(...arguments),this.hasMixedImageFormats=!0}get imageFormatIsOpaque(){return!1}get fullExtent(){return this.layer.fullExtent}get isOpaque(){return this.fullOpacity>=1&&this.imageFormatIsOpaque}get visibleAtCurrentScale(){if(!(0,u.Av)(this.layer.minScale,this.layer.maxScale)||!this.view.scale)return!0;const e=Math.round(this.view.basemapTerrain.tilingScheme.levelAtScale(this.view.scale));return e>=this.displayLevelRange.minLevel&&e<=this.displayLevelRange.maxLevel}get dataScaleRange(){const e=this.tileInfo.lods;let t=e[0].scale,i=e[e.length-1].scale;if("tilemapCache"in this.layer&&this.layer.tilemapCache){const{effectiveMinLOD:e,effectiveMaxLOD:a}=this.layer.tilemapCache;t=this.tileInfo.lodAt(e).scale,i=this.tileInfo.lodAt(a).scale}return{minScale:t,maxScale:i}}canResume(){const e=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&this.layer?.loaded&&!this.parent?.suspended&&this.view?.ready&&(0,u.Cy)(e)&&this.visibleAtCurrentTimeExtent||!1}get dataLevelRange(){const{minScale:e,maxScale:t}=this.dataScaleRange;return this.levelRangeFromScaleRange(e,t)}get displayLevelRange(){const e=this.layer.minScale||this.dataScaleRange.minScale,t=this.layer.maxScale||this.dataScaleRange.maxScale,i=this.levelRangeFromScaleRange(e,t);return this.layer.maxScale&&i.maxLevel++,i}get performanceInfo(){return new l.W(this.view.basemapTerrain.getUsedMemoryForLayerView(this))}getTileUrl(e){return this.layer.getTileUrl(e[0],e[1],e[2])}_addTilingSchemeMatchPromise(){if(null==this.fullExtent)return this.addResolvingPromise(Promise.reject(new n.Z("tilingscheme:extent-not-defined","This layer doesn't define a fullExtent.")));const e=this._getTileInfoSupportError(this.tileInfo,this.fullExtent);if(e)return this.addResolvingPromise(Promise.reject(e));this.addResolvingPromise((0,s.N1)((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const e=this.view.basemapTerrain.tilingScheme,t="tilemapCache"in this.layer?this.layer.tilemapCache?.effectiveMaxLOD:void 0,i=this._getTileInfoCompatibilityError(this.tileInfo,e,t);if(i)throw i})))}_getTileInfoSupportError(e,t){const i=(0,c.er)(e,t,this.view.spatialReference,this.view.state.viewingMode,"tilemapCache"in this.layer?this.layer.tilemapCache?.effectiveMaxLOD:void 0);if(!i)return;const a={layer:this.layer,error:i};switch(i.name){case"tilingscheme:spatial-reference-mismatch":case"tilingscheme:global-unsupported-spatial-reference":case"tilingscheme:local-unsupported-spatial-reference":return new n.Z("layerview:spatial-reference-incompatible","The spatial reference of this layer does not meet the requirements of the view",a);default:return new n.Z("layerview:tiling-scheme-unsupported","The tiling scheme of this layer is not supported by SceneView",a)}}_getTileInfoCompatibilityError(e,t,i){return null!=e&&t.compatibleWith(e,i)?null:new n.Z("layerview:tiling-scheme-incompatible","The tiling scheme of this layer is incompatible with the tiling scheme of the surface")}levelRangeFromScaleRange(e,t){const i={minLevel:0,maxLevel:1/0},a=this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.tilingScheme;if(!a)return i;const n=a.levels[0],s=e=>{const t=Math.log(n.scale/e)/Math.LN2;return.5-Math.abs(.5-t%1)<1e-9?Math.round(t):Math.ceil(t)};return null!=e&&e>0&&(i.minLevel=Math.max(0,s(e))),null!=t&&t>0&&(i.maxLevel=Math.max(0,s(t))),i}isUpdating(){return!!(this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.updating)}};return(0,a._)([(0,r.Cb)({readOnly:!0})],t.prototype,"imageFormatIsOpaque",null),(0,a._)([(0,r.Cb)({readOnly:!0})],t.prototype,"updating",void 0),(0,a._)([(0,r.Cb)(h.q)],t.prototype,"updatingProgress",void 0),(0,a._)([(0,r.Cb)(h.V)],t.prototype,"updatingProgressValue",void 0),(0,a._)([(0,r.Cb)()],t.prototype,"hasMixedImageFormats",void 0),(0,a._)([(0,r.Cb)()],t.prototype,"fullExtent",null),(0,a._)([(0,r.Cb)({readOnly:!0})],t.prototype,"isOpaque",null),(0,a._)([(0,r.Cb)({readOnly:!0})],t.prototype,"visibleAtCurrentScale",null),(0,a._)([(0,r.Cb)()],t.prototype,"dataScaleRange",null),(0,a._)([(0,r.Cb)({readOnly:!0})],t.prototype,"dataLevelRange",null),(0,a._)([(0,r.Cb)({readOnly:!0})],t.prototype,"displayLevelRange",null),(0,a._)([(0,r.Cb)()],t.prototype,"layer",void 0),t=(0,a._)([(0,o.j)("esri.views.3d.layers.TiledLayerView3D")],t),t}},79597:(e,t,i)=>{i.r(t),i.d(t,{default:()=>Ue});var a=i(27366),n=i(10064),s=i(93169),r=i(92026),o=i(66978),l=i(94172),h=i(49861),c=(i(32718),i(84936),i(69912));class u{constructor(e,t,i){this._scale=e,this._shift=t,this._levelShift=i}getLevelRowColumn(e){const t=this.getLevelShift(e[0]),i=this._shift+t;return i?[e[0]-t,e[1]>>i,e[2]>>i]:e}getLevelShift(e){return Math.min(e,this._levelShift)}getOffset(e,t){let i=0,a=0;const n=this._shift+this.getLevelShift(e[0]);if(n){const s=(1<<n)-1,r=t/(this._scale*(1<<n-1));i=(e[2]&s)*r,a=(e[1]&s)*r}return[i,a]}getScale(e){return this._scale*(1<<this._shift+this.getLevelShift(e))}}var d=i(18759),p=i(8768),_=i(65156),f=i(35995),g=i(70431),m=i(10106),y=i(12233);class v{constructor(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new y.Z(0,0,e,t))}get width(){return this._width}get height(){return this._height}allocate(e,t){if(e>this._width||t>this._height)return new y.Z;let i=null,a=-1;for(let n=0;n<this._free.length;++n){const s=this._free[n];e<=s.width&&t<=s.height&&(null===i||s.y<=i.y&&s.x<=i.x)&&(i=s,a=n)}return null===i?new y.Z:(this._free.splice(a,1),i.width<i.height?(i.width>e&&this._free.push(new y.Z(i.x+e,i.y,i.width-e,t)),i.height>t&&this._free.push(new y.Z(i.x,i.y+t,i.width,i.height-t))):(i.width>e&&this._free.push(new y.Z(i.x+e,i.y,i.width-e,i.height)),i.height>t&&this._free.push(new y.Z(i.x,i.y+t,e,i.height-t))),new y.Z(i.x,i.y,e,t))}release(e){for(let t=0;t<this._free.length;++t){const i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)}}var w=i(8548),x=i(57808),b=i(52311);class S{constructor(e,t,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=e,this.height=t,this._glyphSource=i,this._binPack=new v(e-4,t-4),this._glyphData.push(new Uint8Array(e*t)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(e,t){const i=[],a=this._glyphSource,n=new Set;for(const r of t){const e=Math.floor(.00390625*r);n.add(e)}const s=[];return n.forEach((t=>{const i=e+t;if(this._rangePromises.has(i))s.push(this._rangePromises.get(i));else{const n=a.getRange(e,t).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,n),s.push(n)}})),Promise.all(s).then((()=>{let n=this._glyphIndex[e];n||(n={},this._glyphIndex[e]=n);for(const s of t){const t=n[s];if(t){i[s]={sdf:!0,rect:t.rect,metrics:t.metrics,page:t.page,code:s};continue}const r=a.getGlyph(e,s);if(!r?.metrics)continue;const o=r.metrics;let l;if(0===o.width)l=new y.Z(0,0,0,0);else{const e=3,t=o.width+2*e,i=o.height+2*e;let a=t%4?4-t%4:4,n=i%4?4-i%4:4;1===a&&(a=5),1===n&&(n=5),l=this._binPack.allocate(t+a,i+n),l.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new v(this.width-4,this.height-4),l=this._binPack.allocate(t+a,i+n));const s=this._glyphData[this._currentPage],h=r.bitmap;let c,u;if(h)for(let r=0;r<i;r++){c=t*r,u=this.width*(l.y+r+1)+l.x;for(let e=0;e<t;e++)s[u+e+1]=h.at(c+e)}}n[s]={rect:l,metrics:o,tileIDs:null,page:this._currentPage},i[s]={sdf:!0,rect:l,metrics:o,page:this._currentPage,code:s},this._dirties[this._currentPage]=!0}return i}))}removeGlyphs(e){for(const t in this._glyphIndex){const i=this._glyphIndex[t];if(!i)continue;let a;for(const t in i)if(a=i[t],a.tileIDs.delete(e),0===a.tileIDs.size){const e=this._glyphData[a.page],n=a.rect;let s,r;for(let t=0;t<n.height;t++)for(s=this.width*(n.y+t)+n.x,r=0;r<n.width;r++)e[s+r]=0;delete i[t],this._dirties[a.page]=!0}}}bind(e,t,i){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(!this._textures[i]){const t=new b.X;t.pixelFormat=w.VI.ALPHA,t.wrapMode=w.e8.CLAMP_TO_EDGE,t.width=this.width,t.height=this.height,this._textures[i]=new x.x(e,t,new Uint8Array(this.width*this.height))}const n=this._textures[i];n.setSamplingMode(t),this._dirties[i]&&n.setData(this._glyphData[i]),e.bindTexture(n,a),this._dirties[i]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const e of this._textures)e&&e.dispose();this._textures.length=0}}var M=i(76200),I=i(78084);class D{constructor(e){if(this._metrics=[],!e)return void(this._allBitmaps=null);const t=new Map;let i=0;for(;e.next();)switch(e.tag()){case 1:{const a=e.getMessage();for(;a.next();)switch(a.tag()){case 3:{const e=a.getMessage();let n,s,r,o,l,h,c;for(;e.next();)switch(e.tag()){case 1:n=e.getUInt32();break;case 2:s=e.getBytes();break;case 3:r=e.getUInt32();break;case 4:o=e.getUInt32();break;case 5:l=e.getSInt32();break;case 6:h=e.getSInt32();break;case 7:c=e.getUInt32();break;default:e.skip()}if(e.release(),n){const e=s?.length??0;this._metrics[n]={width:r,height:o,left:l,top:h,advance:c,startOffset:i,length:e},t.set(n,s),i+=e}break}default:a.skip()}a.release();break}default:e.skip()}const a=new Uint8Array(i),n=this._metrics;for(const[s,r]of t){const{startOffset:e,length:t}=n[s];if(r)for(let i=0;i<t;++i)a[e+i]=r[i]}this._allBitmaps=a}getMetrics(e){return this._metrics[e]}getBitmap(e){if(!this._allBitmaps)return;const t=this._metrics[e];if(void 0===t)return;const{startOffset:i,length:a}=t;return 0!==a?new T(this._allBitmaps,i,a):void 0}}class C{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(e){return this._ranges[e]}addRange(e,t){this._ranges[e]=t}}class P{constructor(e){this._glyphInfo={},this._baseURL=e}getRange(e,t){const i=this._getFontStack(e);if(i.getRange(t))return Promise.resolve();const a=256*t,n=a+255;if(this._baseURL){const s=this._baseURL.replace("{fontstack}",e).replace("{range}",a+"-"+n);return(0,M.Z)(s,{responseType:"array-buffer"}).then((e=>{i.addRange(t,new D(new I.Z(new Uint8Array(e.data),new DataView(e.data))))})).catch((()=>{i.addRange(t,new D)}))}return i.addRange(t,new D),Promise.resolve()}getGlyph(e,t){const i=this._getFontStack(e);if(!i)return;const a=Math.floor(t/256),n=i.getRange(a);return n?{metrics:n.getMetrics(t),bitmap:n.getBitmap(t)}:void 0}_getFontStack(e){let t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new C),t}}class T{constructor(e,t,i){this._array=e,this._start=t,this.length=i}at(e){return 0<=e&&e<this.length?this._array[this._start+e]:void 0}}var R=i(46228),A=i(16889),L=i(51750);class E{constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,t<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,i>0&&(this._maxItemSize=i),this._binPack=new v(e-4,t-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new v(this._pageWidth-4,this._pageHeight-4);const e=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),i=new Uint32Array(e*t);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e){let t,i,a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this._mosaicRects[e];if(n)return n;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(e&&e.startsWith("dasharray-")?([t,i]=this._rasterizeDash(e),a=!0):t=this._sprites.getSpriteInfo(e),!t?.width||!t.height||t.width<0||t.height<0)return null;const s=t.width,r=t.height,[o,l,h]=this._allocateImage(s,r);return o.width<=0?null:(this._copy(o,t,l,h,a,i),n={type:"sprite",rect:o,width:s,height:r,sdf:t.sdf,simplePattern:!1,rasterizationScale:t.pixelRatio,page:l},this._mosaicRects[e]=n,n)}getSpriteItems(e){const t={};for(const i of e)t[i.name]=this.getSpriteItem(i.name,i.repeat);return t}getMosaicItemPosition(e,t){const i=this.getSpriteItem(e,t),a=i?.rect;if(!a)return null;a.width=i.width,a.height=i.height;const n=i.width,s=i.height;return{tl:[a.x+2,a.y+2],br:[a.x+2+n,a.y+2+s],page:i.page}}bind(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(i>=this._size.length||i>=this._mosaicsData.length)return;if(!this._textures[i]){const t=new b.X;t.wrapMode=w.e8.CLAMP_TO_EDGE,t.width=this._size[i][0],t.height=this._size[i][1],this._textures[i]=new x.x(e,t,new Uint8Array(this._mosaicsData[i].buffer))}const n=this._textures[i];n.setSamplingMode(t),this._dirties[i]&&n.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(n,a),this._dirties[i]=!1}static _copyBits(e,t,i,a,n,s,r,o,l,h,c){let u=a*t+i,d=o*s+r;if(c){d-=s;for(let r=-1;r<=h;r++,u=((r+h)%h+a)*t+i,d+=s)for(let t=-1;t<=l;t++)n[d+t]=e[u+(t+l)%l]}else for(let p=0;p<h;p++){for(let t=0;t<l;t++)n[d+t]=e[u+t];u+=t,d+=s}}_copy(e,t,i,a,n,s){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const r=new Uint32Array(s?s.buffer:this._sprites.image.buffer),o=this._mosaicsData[i],l=s?t.width:this._sprites.width;E._copyBits(r,l,t.x,t.y,o,a[0],e.x+2,e.y+2,t.width,t.height,n),this._dirties[i]=!0}_allocateImage(e,t){e+=2,t+=2;const i=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<i){const i=new y.Z(0,0,e,t);return this._mosaicsData.push(new Uint32Array(e*t)),this._dirties.push(!0),this._size.push([e,t]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[e,t]]}let a=e%4?4-e%4:4,n=t%4?4-t%4:4;1===a&&(a=5),1===n&&(n=5);const s=this._binPack.allocate(e+a,t+n);return s.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new v(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[s,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const t=e.match(/\[(.*?)\]/);if(!t)return null;const i=t[1].split(",").map(Number),a=e.slice(e.lastIndexOf("-")+1),[n,s,r]=function(e,t){null==e&&(e=[]);const i="Butt"===t,a="Square"===t,n=!i&&!a;e.length%2==1&&(e=[...e,...e]);const s=L.v3,r=2*s;let o=0;for(const m of e)o+=m;const l=Math.round(o*s),h=new Float32Array(l*r),c=.5*s;let u=0,d=0,p=.5,_=!0;for(const m of e){for(u=d,d+=m*s;p<=d;){let e=.5;for(;e<r;){const t=(e-.5)*l+p-.5,r=n?(e-s)*(e-s):Math.abs(e-s);h[t]=_?i?Math.max(Math.max(u+c-p,r),Math.max(p-d+c,r)):r:n?Math.min((p-u)*(p-u)+r,(p-d)*(p-d)+r):a?Math.min(Math.max(p-u,r),Math.max(d-p,r)):Math.min(Math.max(p-u+c,r),Math.max(d+c-p,r)),e++}p++}_=!_}const f=h.length,g=new Uint8Array(4*f);for(let m=0;m<f;++m){const e=(n?Math.sqrt(h[m]):h[m])/s;(0,R.I)(e,g,4*m)}return[g,l,r]}(i,a);return[{x:0,y:0,width:s,height:r,sdf:!0,pixelRatio:1},new Uint8Array(n.buffer)]}}var U=i(73828);class O{constructor(e,t,i,a){this._layer=e,this._styleRepository=t,this.devicePixelRatio=i,this._sourceDataMaxLOD=a,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){this._connection?.close(),this._connection=null,this._styleRepository=null,this._layer=null,this._spriteMosaic?.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=(0,r.IM)(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(e){this._requestSprite(e);const t=this._layer.currentStyleInfo.glyphsUrl,i=new P(t?(0,f.fl)(t,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new S(1024,1024,i),this._broadcastPromise=(0,g.bA)("WorkerTileHandler",{client:this,schedule:e.schedule,signal:e.signal}).then((t=>{if(this._layer&&(this._connection?.close(),this._connection=t,this._layer&&!this._connection.closed)){const i=t.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},e);Promise.all(i).catch((e=>(0,o.H9)(e)))}}))}_requestSprite(e){this._spriteSourceAbortController?.abort();const t=new AbortController;this._spriteSourceAbortController=t;const i=e?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener),this._startOptionsInputSignal=null,i&&(this._inputSignalEventListener=function(e){return()=>e.abort()}(t),i.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:a}=t,n={...e,signal:a};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,n),this._spriteSourcePromise.then((e=>{(0,o.r9)(a),this._spriteMosaic=new E(1024,1024,250),this._spriteMosaic.setSpriteSource(e)}))}async updateStyle(e){const t=[];for(const i of e)i.type===m.Fr.SPRITES_CHANGED?t.push({type:m.Fr.SPRITES_CHANGED,data:{spriteSource:null}}):t.push(i);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}setSpriteSource(e){const t=new E(1024,1024,250);return t.setSpriteSource(e),this._spriteMosaic=t,this._spriteSourcePromise=Promise.resolve(e),this._spriteSourceAbortController=null,t}async setStyle(e,t,i){await this._broadcastPromise,this._styleRepository=e,this._sourceDataMaxLOD=i,this._requestSprite();const a=new P(this._layer.currentStyleInfo.glyphsUrl?(0,f.fl)(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new S(1024,1024,a),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:t,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(e,t){const i=await this._getRefKeys(e,t);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),i,t)}async fetchTilePBFs(e){const t=Object.keys(this._layer.sourceNameToSource),i={},a=await this._getRefKeys(e,i),n=[],s=[];for(let r=0;r<a.length;r++)if(null==a[r].value||null==t[r])s.push(null);else{const e=a[r].value,o=this._getTilePayload(e,t[r],i);o.then((t=>{n.push({...t,key:e})})),s.push(o)}return Promise.all(s).then((()=>n))}async parseTileData(e,t){const i=e&&e.data;if(!i)return null;const{sourceName2DataAndRefKey:a,transferList:n}=i;return 0===Object.keys(a).length?null:this._broadcastPromise.then((()=>this._connection.invoke("createTileAndParse",{key:e.key.id,sourceName2DataAndRefKey:a,styleLayerUIDs:e.styleLayerUIDs},{...t,transferList:n})))}async getSprites(e){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(e)}getGlyphs(e){return this._glyphMosaic.getGlyphItems(e.font,e.codePoints)}async _getTilePayload(e,t,i){const a=U.Z.pool.acquire(e.id),n=this._layer.sourceNameToSource[t],{level:s,row:r,col:l}=a;U.Z.pool.release(a);try{return{protobuff:await n.requestTile(s,r,l,i),sourceName:t}}catch(Z){if((0,o.D_)(Z))throw Z;return{protobuff:null,sourceName:t}}}async _getRefKeys(e,t){const i=this._layer.sourceNameToSource,a=new Array;for(const n in i){const s=i[n].getRefKey(e,t);a.push(s)}return(0,o.as)(a)}_getSourcesData(e,t,i){const a=[];for(let n=0;n<t.length;n++)if(null==t[n].value||null==e[n])a.push(null);else{const s=t[n].value,r=this._getTilePayload(s,e[n],i);a.push(r)}return(0,o.as)(a).then((e=>{const i={},a=[];for(let n=0;n<e.length;n++){const s=e[n].value;if(s&&s.protobuff&&s.protobuff.byteLength>0){const e=t[n].value.id;i[s.sourceName]={refKey:e,protobuff:s.protobuff},a.push(s.protobuff)}}return{sourceName2DataAndRefKey:i,transferList:a}}))}}var k=i(29303),V=i(18722),z=i(37995),F=(i(32344),i(85269),i(50127)),N=i(44070),B=i(45412);class W{constructor(e,t){this.layerUIDs=[],this.isDestroyed=!1,this._data=e;let i=1;const a=new Uint32Array(e);this.layerUIDs=[];const n=a[i++];for(let s=0;s<n;s++)this.layerUIDs[s]=a[i++];this.bufferDataOffset=i,t&&(this.layer=t.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(e){null!=this._data&&(this.doPrepareForRendering(e,this._data,this.bufferDataOffset),this._data=null)}}class H extends W{constructor(e,t){super(e,t),this.type=m.al.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const i=new Uint32Array(e);let a=this.bufferDataOffset;this.lineIndexStart=i[a++],this.lineIndexCount=i[a++];const n=i[a++];if(n>0){this.patternMap=new Map;for(let e=0;e<n;e++){const e=i[a++],t=i[a++],n=i[a++];this.patternMap.set(e,[t,n])}}this.bufferDataOffset=a}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=(0,r.M2)(this.vao)}doPrepareForRendering(e,t,i){const a=new Uint32Array(t),n=new Int32Array(a.buffer),s=a[i++],r=N.f.createVertex(e,w.l1.STATIC_DRAW,new Int32Array(n.buffer,4*i,s));i+=s;const o=a[i++],l=N.f.createIndex(e,w.l1.STATIC_DRAW,new Uint32Array(a.buffer,4*i,o));i+=o;const h=this.layer.lineMaterial;this.vao=new B.U(e,h.getAttributeLocations(),h.getLayoutInfo(),new Map([["geometry",r]]),l)}}class q extends W{constructor(e,t){super(e,t),this.type=m.al.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const i=new Uint32Array(e);let a=this.bufferDataOffset;this.fillIndexStart=i[a++],this.fillIndexCount=i[a++],this.outlineIndexStart=i[a++],this.outlineIndexCount=i[a++];const n=i[a++];if(n>0){this.patternMap=new Map;for(let e=0;e<n;e++){const e=i[a++],t=i[a++],n=i[a++];this.patternMap.set(e,[t,n])}}this.bufferDataOffset=a}get usedMemory(){return(this.data?.byteLength??0)+(this.fillVAO?.usedMemory??0)+(this.outlineVAO?.usedMemory??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=(0,r.M2)(this.fillVAO),this.outlineVAO=(0,r.M2)(this.outlineVAO)}doPrepareForRendering(e,t,i){const a=new Uint32Array(t),n=new Int32Array(a.buffer),s=a[i++],r=N.f.createVertex(e,w.l1.STATIC_DRAW,new Int32Array(n.buffer,4*i,s));i+=s;const o=a[i++],l=N.f.createIndex(e,w.l1.STATIC_DRAW,new Uint32Array(a.buffer,4*i,o));i+=o;const h=a[i++],c=N.f.createVertex(e,w.l1.STATIC_DRAW,new Int32Array(n.buffer,4*i,h));i+=h;const u=a[i++],d=N.f.createIndex(e,w.l1.STATIC_DRAW,new Uint32Array(a.buffer,4*i,u));i+=u;const p=this.layer,_=p.fillMaterial,f=p.outlineMaterial;this.fillVAO=new B.U(e,_.getAttributeLocations(),_.getLayoutInfo(),new Map([["geometry",r]]),l),this.outlineVAO=new B.U(e,f.getAttributeLocations(),f.getLayoutInfo(),new Map([["geometry",c]]),d)}}class G extends W{constructor(e,t,i){super(e,t),this.type=m.al.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const a=new Uint32Array(e),n=new Int32Array(e),s=new Float32Array(e);let r=this.bufferDataOffset;this.isIconSDF=!!a[r++];const o=a[r++],l=a[r++],h=a[r++],c=new U.Z(o,l,h,0),u=a[r++];for(let f=0;f<u;f++){const e=a[r++],t=a[r++],i=a[r++];this.iconPerPageElementsMap.set(e,[t,i])}const d=a[r++];for(let f=0;f<d;f++){const e=a[r++],t=a[r++],i=a[r++];this.glyphPerPageElementsMap.set(e,[t,i])}const p=a[r++],_=a[r++];this.iconOpacity=new Int32Array(p),this.textOpacity=new Int32Array(_),r=(0,F.wB)(a,n,s,r,this.symbols,i,c),this.bufferDataOffset=r}get usedMemory(){return(this.data?.byteLength??0)+(this.iconVAO?.usedMemory??0)+(this.textVAO?.usedMemory??0)+(0,V.Xw)(this.iconOpacity)+(0,V.Xw)(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const t of this.iconPerPageElementsMap.values())e+=t[1];for(const t of this.glyphPerPageElementsMap.values())e+=t[1];return e/3}doDestroy(){this.iconVAO=(0,r.M2)(this.iconVAO),this.textVAO=(0,r.M2)(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=this.iconOpacity,t=this.iconVAO.vertexBuffers.get("opacity");e.length>0&&e.byteLength===t.usedMemory&&t.setSubData(e,0,0,e.length);const i=this.textOpacity,a=this.textVAO.vertexBuffers.get("opacity");i.length>0&&i.byteLength===a.usedMemory&&a.setSubData(i,0,0,i.length)}doPrepareForRendering(e,t,i){const a=new Uint32Array(t),n=new Int32Array(a.buffer),s=a[i++],r=N.f.createVertex(e,w.l1.STATIC_DRAW,new Int32Array(n.buffer,4*i,s));i+=s;const o=a[i++],l=N.f.createIndex(e,w.l1.STATIC_DRAW,new Uint32Array(a.buffer,4*i,o));i+=o;const h=a[i++],c=N.f.createVertex(e,w.l1.STATIC_DRAW,new Int32Array(n.buffer,4*i,h));i+=h;const u=a[i++],d=N.f.createIndex(e,w.l1.STATIC_DRAW,new Uint32Array(a.buffer,4*i,u));i+=u;const p=N.f.createVertex(e,w.l1.STATIC_DRAW,this.iconOpacity.buffer),_=N.f.createVertex(e,w.l1.STATIC_DRAW,this.textOpacity.buffer),f=this.layer,g=f.iconMaterial,m=f.textMaterial;this.iconVAO=new B.U(e,g.getAttributeLocations(),g.getLayoutInfo(),new Map([["geometry",r],["opacity",p]]),l),this.textVAO=new B.U(e,m.getAttributeLocations(),m.getLayoutInfo(),new Map([["geometry",c],["opacity",_]]),d)}}class Z extends W{constructor(e,t){super(e,t),this.type=m.al.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const i=new Uint32Array(e);let a=this.bufferDataOffset;this.circleIndexStart=i[a++],this.circleIndexCount=i[a++],this.bufferDataOffset=a}get usedMemory(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=(0,r.M2)(this.vao)}doPrepareForRendering(e,t,i){const a=new Uint32Array(t),n=new Int32Array(a.buffer),s=a[i++],r=N.f.createVertex(e,w.l1.STATIC_DRAW,new Int32Array(n.buffer,4*i,s));i+=s;const o=a[i++],l=N.f.createIndex(e,w.l1.STATIC_DRAW,new Uint32Array(a.buffer,4*i,o));i+=o;const h=this.layer.circleMaterial;this.vao=new B.U(e,h.getAttributeLocations(),h.getLayoutInfo(),new Map([["geometry",r]]),l)}}var K=i(46618),X=i(53364);class Y extends X.I{constructor(e,t,i,a,n,s,r){let o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;super(e,t,i,a,n,s,4096,4096),this.styleRepository=r,this._memCache=o,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=e.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<K.v7}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<K.v7)}get wasRequested(){return"errored"===this.status||"loaded"===this.status||"reloading"===this.status}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(e){let t=!1;for(const i of e){const e=this.layerData.get(i);e&&(this._usedMemory-=e.usedMemory,e.type===m.al.SYMBOL&&this.symbols.delete(i)&&(t=!0),e.destroy(),this.layerData.delete(i))}this._memCache?.updateSize(this.key.id,this,this._usedMemory),t&&(this.featureIndex?.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const e=this.layerData.values();for(const t of e)if(t.hasData())return!0;return!1}dispose(){"unloaded"!==this.status&&(Y._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){0==--this._referenced&&(this.dispose(),this.stage=null)}retain(){++this._referenced}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(e){this.featureIndex?.clear();let t=!1;if(e){const{bucketsWithData:i,emptyBuckets:a}=e,n=this._createRenderBuckets(i);if(a&&a.byteLength>0){const e=new Uint32Array(a);for(const t of e)this._deleteLayerData(t)}for(const[e,s]of n)this._deleteLayerData(e),s.type===m.al.SYMBOL&&(this.symbols.set(e,s.symbols),t=!0),this._usedMemory+=s.usedMemory,this.layerData.set(e,s);this._memCache?.updateSize(this.key.id,this,this.usedMemory)}this._hasSymbolBuckets=!1;for(const i of this.layerData.values())i.type===m.al.SYMBOL&&(this._hasSymbolBuckets=!0);t&&this.emit("symbols-changed")}attachWithContext(e){this.stage={context:e,trashDisplayObject(e){e.processDetach()},untrashDisplayObject:()=>!1}}setTransform(e){super.setTransform(e);const t=this.resolution/(e.resolution*e.pixelRatio),i=this.width/this.rangeX*t,a=this.height/this.rangeY*t,n=[0,0];e.toScreen(n,[this.x,this.y]);const s=this.transforms.tileUnitsToPixels;(0,k.yR)(s),(0,k.Iu)(s,s,n),(0,k.U1)(s,s,Math.PI*e.rotation/180),(0,k.bA)(s,s,[i,a,1])}_createTransforms(){return{displayViewScreenMat3:(0,p.Ue)(),tileMat3:(0,p.Ue)(),tileUnitsToPixels:(0,p.Ue)()}}static _destroyRenderBuckets(e){if(!e)return;const t=new Set;for(const i of e.values())t.has(i)||(i.destroy(),t.add(i));e.clear()}_createRenderBuckets(e){const t=new Map,i=new Map;for(const a of e){const e=this._deserializeBucket(a,i);for(const i of e.layerUIDs)t.set(i,e)}return t}_deserializeBucket(e,t){let i=t.get(e);if(i)return i;switch(new Uint32Array(e)[0]){case m.al.FILL:i=new q(e,this.styleRepository);break;case m.al.LINE:i=new H(e,this.styleRepository);break;case m.al.SYMBOL:i=new G(e,this.styleRepository,this);break;case m.al.CIRCLE:i=new Z(e,this.styleRepository)}return t.set(e,i),i}_deleteLayerData(e){if(!this.layerData.has(e))return;const t=this.layerData.get(e);this._usedMemory-=t.usedMemory,t.destroy(),this.layerData.delete(e)}}var $=i(22824);class j extends z.Z{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const t=U.Z.pool.acquire(e),i=0===t.level?null:U.Z.getId(t.level-1,t.row>>1,t.col>>1,t.world);return U.Z.pool.release(t),i}getTileCoverage(e,t){let i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=arguments.length>3?arguments[3]:void 0;const n=super.getTileCoverage(e,t,i,a);if(!n)return n;const s=1<<n.lodInfo.level;return n.spans=n.spans.filter((e=>e.row>=0&&e.row<s)),n}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const t=this._fullCacheLodInfos;if(e>t[0].scale)return t[0].level;let i,a;for(let n=0;n<t.length-1;n++)if(a=t[n+1],e>a.scale)return i=t[n],i.level+(i.scale-e)/(i.scale-a.scale);return t[t.length-1].level}}_initializeFullCacheLODs(e){let t;if(0===e[0].level)t=e.map((e=>({level:e.level,resolution:e.resolution,scale:e.scale})));else{const e=this.tileInfo.size[0],i=this.tileInfo.spatialReference;t=$.Z.create({size:e,spatialReference:i}).lods.map((e=>({level:e.level,resolution:e.resolution,scale:e.scale})))}for(let i=0;i<t.length;i++)this._levelByScale[t[i].scale]=t[i].level;this._fullCacheLodInfos=t}}class Q extends O{constructor(e,t,i,a){super(e,t,i,e.tileInfo.lods.length-1),this._memCache=a,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new j(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach((e=>e.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t){const i=new U.Z(e[0],e[1],e[2],0);let a=this._memCache.get(i.id);if(a)return a.retain(),a;const n=await this._getVectorTileData(i);if((0,o.k_)(t),!this._layer)return null;if(a=this._memCache.get(i.id),a)return a.retain(),a;const s=this._layer.tileInfo.getTileBounds((0,_.Ue)(),i),r=this._tileInfoView.getTileResolution(e[0]);return a=new Y(i,r,s[0],s[3],512,512,this._styleRepository,this._memCache),a.setData(n),n&&(a.retain(),this._memCache.put(i.id,a,a.usedMemory,d.M4)),a.neededForCoverage=!0,a.transforms.tileUnitsToPixels=(0,p.al)(1/8,0,0,0,1/8,0,0,0,1),a}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,a={signal:i.signal},n=this._getParsedVectorTileData(e,a).then((e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e))).catch((()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null)));return this._ongoingTileRequests.set(t,n),this._ongoingRequestToController.set(t,i),n}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then((i=>this.parseTileData({key:e,data:i},t)))}}var J=i(99894),ee=i(94109);class te{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,t){}draw(e,t,i){}drawMany(e,t,i){for(const a of t)a.visible&&this.draw(e,a,i)}}var ie=i(21391);const ae=1/65536;var ne=i(30932);Math.PI,Math.LN2;function se(e,t){return(e%=t)>=0?e:e+t}function re(e){return se(.7111111111111111*e,256)}const oe={vtlBackground:class extends te{constructor(){super(...arguments),this._color=(0,J.al)(1,0,0,1),this._patternMatrix=(0,p.Ue)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,t){const{context:i,painter:a,requestRender:n,allowDelayedRender:s}=e;this._loadWGLResources(e);const r=e.displayLevel,o=e.styleLayer,l=o.backgroundMaterial,h=a.vectorTilesMaterialManager,c=o.getPaintValue("background-color",r),u=o.getPaintValue("background-opacity",r),d=o.getPaintValue("background-pattern",r),p=void 0!==d,_=1|window.devicePixelRatio,f=e.spriteMosaic;let g,m;const y=_>ee.Vo?2:1,v=this._programOptions;v.pattern=p;const x=h.getMaterialProgram(i,l,v);if(!s||null==n||x.compiled){if(i.bindVAO(this._vao),i.useProgram(x),p){const e=f.getMosaicItemPosition(d,!0);if(null!=e){const{tl:t,br:a,page:n}=e;g=a[0]-t[0],m=a[1]-t[1];const s=f.getPageSize(n);null!=s&&(f.bind(i,w.cw.LINEAR,n,ee.dD),x.setUniform4f("u_tlbr",t[0],t[1],a[0],a[1]),x.setUniform2fv("u_mosaicSize",s),x.setUniform1i("u_texture",ee.dD))}x.setUniform1f("u_opacity",u)}else{const e=c[3]*u;this._color[0]=e*c[0],this._color[1]=e*c[1],this._color[2]=e*c[2],this._color[3]=e,x.setUniform4fv("u_color",this._color)}x.setUniform1f("u_depth",o.z||0);for(const e of t){if(x.setUniform1f("u_coord_range",e.rangeX),x.setUniformMatrix3fv("u_dvsMat3",e.transforms.displayViewScreenMat3),p){const t=Math.max(2**(Math.round(r)-e.key.level),1),i=y*e.width*t,a=i/(0,A.fp)(g),n=i/(0,A.fp)(m);this._patternMatrix[0]=a,this._patternMatrix[4]=n,x.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}i.setStencilFunction(w.wb.EQUAL,0,255),i.drawArrays(w.MX.TRIANGLE_STRIP,0,4)}}else n()}_loadWGLResources(e){if(this._vao)return;const{context:t,styleLayer:i}=e,a=i.backgroundMaterial,n=new Int8Array([0,0,1,0,0,1,1,1]),s=N.f.createVertex(t,w.l1.STATIC_DRAW,n),r=new B.U(t,a.getAttributeLocations(),a.getLayoutInfo(),new Map([["geometry",s]]));this._vao=r}},vtlFill:class extends te{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,t){const{displayLevel:i,renderPass:a,spriteMosaic:n,styleLayerUID:s}=e;let r=!1;for(const y of t)if(y.layerData.has(s)){const e=y.layerData.get(s);if(e.fillIndexCount>0||e.outlineIndexCount>0){r=!0;break}}if(!r)return;const o=e.styleLayer,l=o.getPaintProperty("fill-pattern"),h=void 0!==l,c=h&&l.isDataDriven;let u;if(h&&!c){const e=l.getValue(i);u=n.getMosaicItemPosition(e,!0)}const d=!h&&o.getPaintValue("fill-antialias",i);let p=!0,_=1;if(!h){const e=o.getPaintProperty("fill-color"),t=o.getPaintProperty("fill-opacity");if(!e?.isDataDriven&&!t?.isDataDriven){const e=o.getPaintValue("fill-color",i);_=o.getPaintValue("fill-opacity",i)*e[3],_>=1&&(p=!1)}}if(p&&"opaque"===a)return;const f=o.getPaintValue("fill-translate",i),g=o.getPaintValue("fill-translate-anchor",i);(p||"translucent"!==a)&&this._drawFill(e,s,o,t,f,g,h,u,c);const m=!o.hasDataDrivenOutlineColor&&o.outlineUsesFillColor&&_<1;d&&"opaque"!==a&&!m&&this._drawOutline(e,s,o,t,f,g)}_drawFill(e,t,i,a,n,s,r,o,l){if(r&&!l&&null==o)return;const{context:h,displayLevel:c,state:u,painter:d,pixelRatio:p,spriteMosaic:_,requestRender:f,allowDelayedRender:g}=e,m=i.fillMaterial,y=d.vectorTilesMaterialManager,v=p>ee.Vo?2:1,x=this._fillProgramOptions;x.pattern=r;const b=y.getMaterialProgram(h,m,x);if(g&&null!=f&&!b.compiled)return void f();if(h.useProgram(b),null!=o){const{page:e}=o,t=_.getPageSize(e);null!=t&&(_.bind(h,w.cw.LINEAR,e,ee.dD),b.setUniform2fv("u_mosaicSize",t),b.setUniform1i("u_texture",ee.dD))}b.setUniformMatrix3fv("u_displayMat3",s===ie.fD.VIEWPORT?u.displayMat3:u.displayViewMat3),b.setUniform2fv("u_fillTranslation",n),b.setUniform1f("u_depth",i.z+ae);let S=-1;for(const M of a){if(!M.layerData.has(t))continue;M.key.level!==S&&(S=M.key.level,m.setDataUniforms(b,c,i,S,_));const e=M.layerData.get(t);if(!e.fillIndexCount)continue;e.prepareForRendering(h);const a=e.fillVAO;if(null!=a){if(h.bindVAO(a),b.setUniformMatrix3fv("u_dvsMat3",M.transforms.displayViewScreenMat3),h.setStencilFunction(w.wb.EQUAL,M.stencilRef,255),r){const e=Math.max(2**(Math.round(c)-M.key.level),1),t=M.rangeX/(v*M.width*e);b.setUniform1f("u_patternFactor",t)}if(l){const t=e.patternMap;if(!t)continue;for(const[e,i]of t){const t=_.getPageSize(e);null!=t&&(_.bind(h,w.cw.LINEAR,e,ee.dD),b.setUniform2fv("u_mosaicSize",t),b.setUniform1i("u_texture",ee.dD),h.drawElements(w.MX.TRIANGLES,i[1],w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]))}}else h.drawElements(w.MX.TRIANGLES,e.fillIndexCount,w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*e.fillIndexStart);M.triangleCount+=e.fillIndexCount/3}}}_drawOutline(e,t,i,a,n,s){const{context:r,displayLevel:o,state:l,painter:h,pixelRatio:c,spriteMosaic:u,requestRender:d,allowDelayedRender:p}=e,_=i.outlineMaterial,f=h.vectorTilesMaterialManager,g=.75/c,m=this._outlineProgramOptions,y=f.getMaterialProgram(r,_,m);if(p&&null!=d&&!y.compiled)return void d();r.useProgram(y),y.setUniformMatrix3fv("u_displayMat3",s===ie.fD.VIEWPORT?l.displayMat3:l.displayViewMat3),y.setUniform2fv("u_fillTranslation",n),y.setUniform1f("u_depth",i.z+ae),y.setUniform1f("u_outline_width",g);let v=-1;for(const x of a){if(!x.layerData.has(t))continue;x.key.level!==v&&(v=x.key.level,_.setDataUniforms(y,o,i,v,u));const e=x.layerData.get(t);if(e.prepareForRendering(r),!e.outlineIndexCount)continue;const a=e.outlineVAO;null!=a&&(r.bindVAO(a),y.setUniformMatrix3fv("u_dvsMat3",x.transforms.displayViewScreenMat3),r.setStencilFunction(w.wb.EQUAL,x.stencilRef,255),r.drawElements(w.MX.TRIANGLES,e.outlineIndexCount,w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*e.outlineIndexStart),x.triangleCount+=e.outlineIndexCount/3)}}},vtlLine:class extends te{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:a,state:n,painter:s,pixelRatio:r,spriteMosaic:o,styleLayerUID:l,requestRender:h,allowDelayedRender:c}=e;if(!t.some((e=>e.layerData.get(l)?.lineIndexCount??!1)))return;const u=e.styleLayer,d=u.lineMaterial,p=s.vectorTilesMaterialManager,_=u.getPaintValue("line-translate",a),f=u.getPaintValue("line-translate-anchor",a),g=u.getPaintProperty("line-pattern"),m=void 0!==g,y=m&&g.isDataDriven;let v,x;if(m&&!y){const e=g.getValue(a);v=o.getMosaicItemPosition(e)}let b=!1;if(!m){const e=u.getPaintProperty("line-dasharray");if(x=void 0!==e,b=x&&e.isDataDriven,x&&!b){const t=e.getValue(a),i=u.getDashKey(t,u.getLayoutValue("line-cap",a));v=o.getMosaicItemPosition(i)}}const S=1/r,M=this._programOptions;M.pattern=m,M.sdf=x;const I=p.getMaterialProgram(i,d,M);if(c&&null!=h&&!I.compiled)return void h();if(i.useProgram(I),I.setUniformMatrix3fv("u_displayViewMat3",n.displayViewMat3),I.setUniformMatrix3fv("u_displayMat3",f===ie.fD.VIEWPORT?n.displayMat3:n.displayViewMat3),I.setUniform2fv("u_lineTranslation",_),I.setUniform1f("u_depth",u.z),I.setUniform1f("u_antialiasing",S),v&&null!=v){const{page:e}=v,t=o.getPageSize(e);null!=t&&(o.bind(i,w.cw.LINEAR,e,ee.dD),I.setUniform2fv("u_mosaicSize",t),I.setUniform1i("u_texture",ee.dD))}let D=-1;for(const C of t){if(!C.layerData.has(l))continue;C.key.level!==D&&(D=C.key.level,d.setDataUniforms(I,a,u,D,o));const e=2**(a-D)/r;I.setUniform1f("u_zoomFactor",e);const t=C.layerData.get(l);if(!t.lineIndexCount)continue;t.prepareForRendering(i);const n=t.vao;if(null!=n){if(i.bindVAO(n),I.setUniformMatrix3fv("u_dvsMat3",C.transforms.displayViewScreenMat3),i.setStencilFunction(w.wb.EQUAL,C.stencilRef,255),y||b){const e=t.patternMap;if(!e)continue;for(const[t,a]of e){const e=o.getPageSize(t);null!=e&&(o.bind(i,w.cw.LINEAR,t,ee.dD),I.setUniform2fv("u_mosaicSize",e),I.setUniform1i("u_texture",ee.dD),i.drawElements(w.MX.TRIANGLES,a[1],w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a[0]))}}else i.drawElements(w.MX.TRIANGLES,t.lineIndexCount,w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t.lineIndexStart);C.triangleCount+=t.lineIndexCount/3}}}},vtlCircle:class extends te{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:a,requiredLevel:n,state:s,painter:r,spriteMosaic:o,styleLayerUID:l,requestRender:h,allowDelayedRender:c}=e;if(!t.some((e=>e.layerData.get(l)?.circleIndexCount??!1)))return;const u=e.styleLayer,d=u.circleMaterial,p=r.vectorTilesMaterialManager,_=u.getPaintValue("circle-translate",a),f=u.getPaintValue("circle-translate-anchor",a),g=this._programOptions,m=p.getMaterialProgram(i,d,g);if(c&&null!=h&&!m.compiled)return void h();i.useProgram(m),m.setUniformMatrix3fv("u_displayMat3",f===ie.fD.VIEWPORT?s.displayMat3:s.displayViewMat3),m.setUniform2fv("u_circleTranslation",_),m.setUniform1f("u_depth",u.z),m.setUniform1f("u_antialiasingWidth",1.2);let y=-1;for(const v of t){if(!v.layerData.has(l))continue;v.key.level!==y&&(y=v.key.level,d.setDataUniforms(m,a,u,y,o));const e=v.layerData.get(l);if(!e.circleIndexCount)continue;e.prepareForRendering(i);const t=e.vao;null!=t&&(i.bindVAO(t),m.setUniformMatrix3fv("u_dvsMat3",v.transforms.displayViewScreenMat3),n!==v.key.level?i.setStencilFunction(w.wb.EQUAL,v.stencilRef,255):i.setStencilFunction(w.wb.GREATER,255,255),i.drawElements(w.MX.TRIANGLES,e.circleIndexCount,w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*e.circleIndexStart),v.triangleCount+=e.circleIndexCount/3)}}},vtlSymbol:class extends te{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=(0,ne.Ue)()}dispose(){}drawMany(e,t){const i=e.styleLayer;this._drawIcons(e,i,t),this._drawText(e,i,t)}_drawIcons(e,t,i){const{context:a,displayLevel:n,painter:s,spriteMosaic:r,state:o,styleLayerUID:l,requestRender:h,allowDelayedRender:c}=e,u=t.iconMaterial,d=s.vectorTilesMaterialManager;let p,_=!1;for(const M of i)if(M.layerData.has(l)&&(p=M.layerData.get(l),p.iconPerPageElementsMap.size>0)){_=!0;break}if(!_)return;const f=t.getPaintValue("icon-translate",n),g=t.getPaintValue("icon-translate-anchor",n);let m=t.getLayoutValue("icon-rotation-alignment",n);m===ie.aF.AUTO&&(m=t.getLayoutValue("symbol-placement",n)===ie.R.POINT?ie.aF.VIEWPORT:ie.aF.MAP);const y=m===ie.aF.MAP,v=t.getLayoutValue("icon-keep-upright",n)&&y,w=p.isIconSDF,x=this._iconProgramOptions;x.sdf=w;const b=d.getMaterialProgram(a,u,x);if(c&&null!=h&&!b.compiled)return void h();a.useProgram(b),b.setUniformMatrix3fv("u_displayViewMat3",m===ie.aF.MAP?o.displayViewMat3:o.displayMat3),b.setUniformMatrix3fv("u_displayMat3",g===ie.fD.VIEWPORT?o.displayMat3:o.displayViewMat3),b.setUniform2fv("u_iconTranslation",f),b.setUniform1f("u_depth",t.z),b.setUniform1f("u_mapRotation",re(o.rotation)),b.setUniform1f("u_keepUpright",v?1:0),b.setUniform1f("u_level",10*n),b.setUniform1i("u_texture",ee.dD),b.setUniform1f("u_fadeDuration",K.v7/1e3);let S=-1;for(const M of i){if(!M.layerData.has(l))continue;if(M.key.level!==S&&(S=M.key.level,u.setDataUniforms(b,n,t,S,r)),p=M.layerData.get(l),0===p.iconPerPageElementsMap.size)continue;p.prepareForRendering(a),p.updateOpacityInfo();const i=p.iconVAO;if(null!=i){a.bindVAO(i),b.setUniformMatrix3fv("u_dvsMat3",M.transforms.displayViewScreenMat3),b.setUniform1f("u_time",(performance.now()-p.lastOpacityUpdate)/1e3);for(const[t,i]of p.iconPerPageElementsMap)this._renderIconRange(e,b,i,t,M)}}}_renderIconRange(e,t,i,a,n){const{context:s,spriteMosaic:r}=e;this._spritesTextureSize[0]=r.getWidth(a)/4,this._spritesTextureSize[1]=r.getHeight(a)/4,t.setUniform2fv("u_mosaicSize",this._spritesTextureSize),r.bind(s,w.cw.LINEAR,a,ee.dD),this._setStencilState(e,n),s.drawElements(w.MX.TRIANGLES,i[1],w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),n.triangleCount+=i[1]/3}_drawText(e,t,i){const{context:a,displayLevel:n,glyphMosaic:s,painter:r,pixelRatio:o,spriteMosaic:l,state:h,styleLayerUID:c,requestRender:u,allowDelayedRender:d}=e,p=t.textMaterial,_=r.vectorTilesMaterialManager;let f,g=!1;for(const L of i)if(L.layerData.has(c)&&(f=L.layerData.get(c),f.glyphPerPageElementsMap.size>0)){g=!0;break}if(!g)return;const m=t.getPaintProperty("text-opacity");if(m&&!m.isDataDriven&&0===m.getValue(n))return;const y=t.getPaintProperty("text-color"),v=!y||y.isDataDriven||y.getValue(n)[3]>0,w=t.getPaintProperty("text-halo-width"),x=t.getPaintProperty("text-halo-color"),b=(!w||w.isDataDriven||w.getValue(n)>0)&&(!x||x.isDataDriven||x.getValue(n)[3]>0);if(!v&&!b)return;let S=t.getLayoutValue("text-rotation-alignment",n);S===ie.aF.AUTO&&(S=t.getLayoutValue("symbol-placement",n)===ie.R.POINT?ie.aF.VIEWPORT:ie.aF.MAP);const M=S===ie.aF.MAP,I=t.getLayoutValue("text-keep-upright",n)&&M,D=.8*3/o;this._glyphTextureSize||(this._glyphTextureSize=(0,ne.al)(s.width/4,s.height/4));const C=t.getPaintValue("text-translate",n),P=t.getPaintValue("text-translate-anchor",n),T=this._sdfProgramOptions,R=_.getMaterialProgram(a,p,T);if(d&&null!=u&&!R.compiled)return void u();a.useProgram(R),R.setUniformMatrix3fv("u_displayViewMat3",S===ie.aF.MAP?h.displayViewMat3:h.displayMat3),R.setUniformMatrix3fv("u_displayMat3",P===ie.fD.VIEWPORT?h.displayMat3:h.displayViewMat3),R.setUniform2fv("u_textTranslation",C),R.setUniform1f("u_depth",t.z+152587890625e-16),R.setUniform2fv("u_mosaicSize",this._glyphTextureSize),R.setUniform1f("u_mapRotation",re(h.rotation)),R.setUniform1f("u_keepUpright",I?1:0),R.setUniform1f("u_level",10*n),R.setUniform1i("u_texture",ee._E),R.setUniform1f("u_antialiasingWidth",D),R.setUniform1f("u_fadeDuration",K.v7/1e3);let A=-1;for(const L of i){if(!L.layerData.has(c))continue;if(L.key.level!==A&&(A=L.key.level,p.setDataUniforms(R,n,t,A,l)),f=L.layerData.get(c),0===f.glyphPerPageElementsMap.size)continue;f.prepareForRendering(a),f.updateOpacityInfo();const i=f.textVAO;if(null==i)continue;a.bindVAO(i),R.setUniformMatrix3fv("u_dvsMat3",L.transforms.displayViewScreenMat3),this._setStencilState(e,L);const r=(performance.now()-f.lastOpacityUpdate)/1e3;R.setUniform1f("u_time",r),f.glyphPerPageElementsMap.forEach(((e,t)=>{this._renderGlyphRange(a,e,t,s,R,b,v,L)}))}}_renderGlyphRange(e,t,i,a,n,s,r,o){a.bind(e,w.cw.LINEAR,i,ee._E),s&&(n.setUniform1f("u_halo",1),e.drawElements(w.MX.TRIANGLES,t[1],w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),o.triangleCount+=t[1]/3),r&&(n.setUniform1f("u_halo",0),e.drawElements(w.MX.TRIANGLES,t[1],w.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),o.triangleCount+=t[1]/3)}_setStencilState(e,t){const{context:i,is3D:a,stencilSymbols:n}=e;if(i.setStencilTestEnabled(!0),n)return i.setStencilWriteMask(255),void i.setStencilFunction(w.wb.ALWAYS,t.stencilRef,255);i.setStencilWriteMask(0),a?i.setStencilFunction(w.wb.EQUAL,t.stencilRef,255):i.setStencilFunction(w.wb.GREATER,255,255)}}},le={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};const he=new class{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Map;if(t.has(e))return t.get(e);const i=this._read(e);if(!i)throw new Error(`cannot find shader file ${e}`);const a=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let n=a.exec(i);const s=[];for(;null!=n;)s.push({path:n[1],start:n.index,length:n[0].length}),n=a.exec(i);let r=0,o="";return s.forEach((e=>{o+=i.slice(r,e.start),o+=t.has(e.path)?"":this._resolve(e.path,t),r=e.start+e.length})),o+=i.slice(r),t.set(e,o),o}_read(e){return this._readFile(e)}}((function(e){let t=le;return e.split("/").forEach((e=>{t&&(t=t[e])})),t}));function ce(e){return he.resolveIncludes(e)}function ue(e){const{options:t,value:i}=e;return"number"==typeof t[i]}function de(e){let t="";for(const i in e){const a=e[i];if("boolean"==typeof a)a&&(t+=`#define ${i}\n`);else if("number"==typeof a)t+=`#define ${i} ${a.toFixed()}\n`;else if("object"==typeof a)if(ue(a)){const{value:e,options:n,namespace:s}=a,r=s?`${s}_`:"";for(const i in n)t+=`#define ${r}${i} ${n[i].toFixed()}\n`;t+=`#define ${i} ${r}${e}\n`}else{const e=a.options;let n=0;for(const i in e)t+=`#define ${e[i]} ${(n++).toFixed()}\n`;t+=`#define ${i} ${e[a.value]}\n`}}return t}const pe=e=>de({PATTERN:e.pattern}),_e={shaders:e=>({vertexShader:pe(e)+ce("background/background.vert"),fragmentShader:pe(e)+ce("background/background.frag")})},fe={shaders:e=>({vertexShader:ce("circle/circle.vert"),fragmentShader:ce("circle/circle.frag")})},ge=e=>de({PATTERN:e.pattern}),me={shaders:e=>({vertexShader:ge(e)+ce("fill/fill.vert"),fragmentShader:ge(e)+ce("fill/fill.frag")})},ye={shaders:e=>({vertexShader:ce("outline/outline.vert"),fragmentShader:ce("outline/outline.frag")})},ve=e=>de({SDF:e.sdf}),we={shaders:e=>({vertexShader:ve(e)+ce("icon/icon.vert"),fragmentShader:ve(e)+ce("icon/icon.frag")})},xe=e=>de({PATTERN:e.pattern,SDF:e.sdf}),be={shaders:e=>({vertexShader:xe(e)+ce("line/line.vert"),fragmentShader:xe(e)+ce("line/line.frag")})},Se={shaders:e=>({vertexShader:ce("text/text.vert"),fragmentShader:ce("text/text.frag")})};class Me{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach((e=>e.dispose())),this._programByKey.clear()}getMaterialProgram(e,t,i){const a=t.key<<3|this._getMaterialOptionsValue(t.type,i);if(this._programByKey.has(a))return this._programByKey.get(a);const n=this._getProgramTemplate(t.type),{shaders:s}=n,{vertexShader:r,fragmentShader:o}=s(i),l=t.getShaderHeader(),h=t.getShaderMain(),c=r.replace("#pragma header",l).replace("#pragma main",h),u=e.programCache.acquire(c,o,t.getAttributeLocations());return this._programByKey.set(a,u),u}_getMaterialOptionsValue(e,t){switch(e){case m._K.BACKGROUND:case m._K.FILL:return(t.pattern?1:0)<<1;case m._K.OUTLINE:return 0;case m._K.LINE:{const e=t;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1}case m._K.ICON:return(t.sdf?1:0)<<1;case m._K.CIRCLE:case m._K.TEXT:default:return 0}}_getProgramTemplate(e){switch(e){case m._K.BACKGROUND:return _e;case m._K.CIRCLE:return fe;case m._K.FILL:return me;case m._K.ICON:return we;case m._K.LINE:return be;case m._K.OUTLINE:return ye;case m._K.TEXT:return Se;default:return null}}}const Ie=1e-6;class De{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache={vtlBackground:null,vtlFill:null,vtlLine:null,vtlCircle:null,vtlSymbol:null},this._vtlMaterialManager=new Me}dispose(){this._brushCache.vtlBackground?.dispose(),this._brushCache.vtlFill?.dispose(),this._brushCache.vtlLine?.dispose(),this._brushCache.vtlCircle?.dispose(),this._brushCache.vtlSymbol?.dispose(),this._brushCache=null,this._vtlMaterialManager=(0,r.M2)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawSymbols(e,t,i){const a=i.layers;e.renderPass="translucent";let n=this._brushCache.vtlSymbol;null==n&&(n=new oe.vtlSymbol,this._brushCache.vtlSymbol=n);for(let s=0;s<a.length;s++){const i=a[s];if(i.type!==ie.fR.SYMBOL)continue;const r=i.getLayoutProperty("visibility");if(r&&r.getValue()===ie.EE.NONE)continue;const o=e.displayLevel;void 0!==i.minzoom&&i.minzoom>o+Ie||void 0!==i.maxzoom&&i.maxzoom<=o-Ie||(e.styleLayerUID=i.uid,e.styleLayer=i,Ce[0]=t,n.drawMany(e,Ce))}}drawBackground(e,t,i){if(0===i.backgroundBucketIds.length)return;const{context:a,displayLevel:n,requiredLevel:s}=e;t.key.level=s,a.setBlendingEnabled(!0),a.setDepthTestEnabled(!1),a.setStencilTestEnabled(!1),e.renderPass="background";let r=this._brushCache.vtlBackground;null==r&&(r=new oe.vtlBackground,this._brushCache.vtlBackground=r),i.backgroundBucketIds.forEach((a=>{const s=i.getLayerById(a);if(s.type!==ie.fR.BACKGROUND)return;const o=s.getLayoutProperty("visibility");o&&o.getValue()===ie.EE.NONE||void 0!==s.minzoom&&s.minzoom>n+Ie||void 0!==s.maxzoom&&s.maxzoom<=n-Ie||(e.styleLayerUID=s.uid,e.styleLayer=s,Ce[0]=t,r.drawMany(e,Ce))}))}drawTile(e,t,i,a){const{context:n}=e,s=i.layers;n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(w.wb.LEQUAL);const r=s.filter((e=>{if(null!=a&&a!==e.type||!t.layerData.has(e.uid))return!1;const i=e.getLayoutProperty("visibility");return i?.getValue()!==ie.EE.NONE}));e.renderPass="opaque";for(let o=r.length-1;o>=0;--o)this._renderStyleLayer(r[o],e,t);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(w.zi.ONE,w.zi.ONE_MINUS_SRC_ALPHA,w.zi.ONE,w.zi.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent",r.forEach((i=>this._renderStyleLayer(i,e,t))),n.setDepthTestEnabled(!1),n.bindVAO()}_renderStyleLayer(e,t,i){const{renderPass:a}=t;let n;switch(e.type){case ie.fR.BACKGROUND:if("background"!==a)return;n=this._brushCache.vtlBackground,n||(n=new oe.vtlBackground,this._brushCache.vtlBackground=n);break;case ie.fR.FILL:if("opaque"!==a&&"translucent"!==t.renderPass)return;n=this._brushCache.vtlFill,null==n&&(n=new oe.vtlFill,this._brushCache.vtlFill=n);break;case ie.fR.LINE:if("translucent"!==a)return;n=this._brushCache.vtlLine,null==n&&(n=new oe.vtlLine,this._brushCache.vtlLine=n);break;case ie.fR.CIRCLE:if("translucent"!==a)return;n=this._brushCache.vtlCircle,null==n&&(n=new oe.vtlCircle,this._brushCache.vtlCircle=n);break;case ie.fR.SYMBOL:if("translucent"!==a)return;n=this._brushCache.vtlSymbol,null==n&&(n=new oe.vtlSymbol,this._brushCache.vtlSymbol=n)}const{displayLevel:s}=t,{minzoom:r,maxzoom:o}=e;if(void 0!==r&&r>s+Ie||void 0!==o&&o<=s-Ie)return;const{context:l}=t;l.setStencilTestEnabled(!1),l.setStencilWriteMask(0),t.styleLayerUID=e.uid,t.styleLayer=e,Ce[0]=i,n.drawMany(t,Ce)}}const Ce=[null];var Pe=i(30969),Te=i(42069),Re=i(77385),Ae=i(53379),Le=i(67581);let Ee=class extends((0,Re.r)((0,Te.A)(Le.Z))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d",this.levelShift=(0,s.Z)("disable-feature:vtl-level-shift")?0:1}initialize(){if(null==this.layer.fullExtent)return void this.addResolvingPromise(Promise.reject(new n.Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:e,spatialReference:t,state:i,viewingMode:a}=this.view,s="local"===a&&!(0,Ae.jO)(t)||Ae.Bu.force512VTL?this.layer.tileInfo:this.layer.tileInfo.getCompatibleForVTL(256),r=this._getTileInfoSupportError(s,this.layer.fullExtent);if(null!=r)return this.addResolvingPromise(Promise.reject(r));const h=(0,l.N1)((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const t=e.tilingScheme,i=t.pixelSize,a=256===i?1:2,n=e.spatialReference?.isGeographic&&256===i?1:0,s=e.spatialReference?.isGeographic||256!==i?0:1;let r;this.schemaHelper=new u(a,n,this.levelShift+s),r=256===i||512===i?this.layer.tileInfo.getCompatibleForVTL(i):this.layer.tileInfo;const o=this._getTileInfoCompatibilityError(r,t);if(o)throw o;this.tileInfo=r}));this._tileHandlerController=new AbortController;const c=this.view.resourceController;this._memCache=c.memoryController.newCache(`vtl-${this.layer.uid}`,(e=>e.release())),this.addHandles((0,l.YP)((()=>this.view.qualitySettings.memoryLimit),(e=>this._memCache.maxSize=Math.ceil(e/10*1048576)),l.tX));const d=new Pe.Z(this.layer.currentStyleInfo.style);this._tileHandler=new Q(this.layer,d,i.contentPixelRatio,this._memCache);const p=this._tileHandlerController.signal,_=function(e){return t=>e.immediate.schedule(t)}(c),f=this._tileHandler.start({signal:p,schedule:_}),g=this._tileHandler.spriteMosaic;g.then((e=>{!(0,o.Hc)(p)&&this._tileHandler&&(this.painter=new De(e,this._tileHandler.glyphMosaic))})),f.then((()=>this._tileHandlerController=null));const m=()=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const e=this.layer.currentStyleInfo.style,t=this.view.state?.contentPixelRatio??1,i=new Pe.Z(e),a=new Q(this.layer,i,t,this._memCache),n=a.start({signal:this._tileHandlerController.signal,schedule:_}),s=a.spriteMosaic;n.then((()=>this._tileHandlerController=null)),this._updatingHandles.addPromise(Promise.all([n,s]).then((e=>{let[,t]=e;const i=this._tileHandler,n=this.painter;this.painter=new De(t,a.glyphMosaic),this._tileHandler=a,this.emit("data-changed"),i.destroy(),n&&n.dispose()})))};this._updatingHandles.add((()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio})),m),this.addHandles([this.layer.on("paint-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-change",m),this.layer.on("delete-style-layer",m),this.layer.on("spriteSource-change",(()=>this.emit("data-changed"))),this.layer.on("layout-change",(()=>this.emit("data-changed"))),this.layer.on("style-layer-visibility-change",(()=>this.emit("data-changed")))]);const y=Promise.all([h,f,g]);this.addResolvingPromise(y)}destroy(){this.painter=(0,r.M2)(this.painter),this._tileHandlerController=(0,r.IM)(this._tileHandlerController),this._tileHandler=(0,r.SC)(this._tileHandler),this._memCache=(0,r.SC)(this._memCache)}get contentZoom(){return(0,s.Z)("disable-feature:vtl-level-shift")?1:this.view.qualitySettings.tiledSurface.vtlContentZoom}get displayLevelRange(){const e=this.tileInfo.lods,t=this.layer.minScale||e[0].scale,i=this.layer.maxScale||e[e.length-1].scale,a=this.levelRangeFromScaleRange(t,i);return this.layer.maxScale?a.maxLevel++:a.maxLevel+=this.levelShift,a}get dataScaleRange(){const e=this.tileInfo.lods;return{minScale:e[0].scale,maxScale:e[e.length-1].scale}}get dataLevelRange(){const{minScale:e,maxScale:t}=this.dataScaleRange,i=this.levelRangeFromScaleRange(e,t);return 1===i.minLevel&&256===this.tileInfo.size[0]&&(i.minLevel=0),i.maxLevel+=this.levelShift,i}async fetchTile(e,t){const i=this.schemaHelper.getLevelRowColumn(e);return this._tileHandler.getVectorTile(i,t)}};(0,a._)([(0,h.Cb)()],Ee.prototype,"layer",void 0),(0,a._)([(0,h.Cb)()],Ee.prototype,"levelShift",void 0),(0,a._)([(0,h.Cb)()],Ee.prototype,"contentZoom",null),(0,a._)([(0,h.Cb)()],Ee.prototype,"displayLevelRange",null),(0,a._)([(0,h.Cb)()],Ee.prototype,"tileInfo",void 0),(0,a._)([(0,h.Cb)()],Ee.prototype,"dataScaleRange",null),(0,a._)([(0,h.Cb)()],Ee.prototype,"dataLevelRange",null),(0,a._)([(0,h.Cb)()],Ee.prototype,"updatingProgressValue",void 0),Ee=(0,a._)([(0,c.j)("esri.views.3d.layers.VectorTileLayerView3D")],Ee);const Ue=Ee},67581:(e,t,i)=>{i.d(t,{Z:()=>f});var a=i(27366),n=i(7138),s=i(91505),r=i(79056),o=i(32718),l=i(92026),h=i(67426),c=i(49861),u=(i(93169),i(84936),i(69912)),d=i(46634),p=i(69787);let _=class extends((0,r.IG)((0,h.v)(s.Z.EventedMixin(n.Z)))){constructor(e){super(e),this._updatingHandles=new d.R,this.layer=null,this.parent=null}initialize(){this.when().catch((e=>{if("layerview:create-error"!==e.name){const t=this.layer&&this.layer.id||"no id",i=this.layer?.title||"no title";o.Z.getLogger(this).error("#resolve()",`Failed to resolve layer view (layer title: '${i}', id: '${t}')`,e)}}))}destroy(){this._updatingHandles=(0,l.SC)(this._updatingHandles)}get fullOpacity(){return(this.layer?.opacity??1)*(this.parent?.fullOpacity??1)}get suspended(){return this.destroyed||!this.canResume()}get suspendInfo(){return this.getSuspendInfo()}get legendEnabled(){return!this.suspended&&!0===this.layer?.legendEnabled}get updating(){return!(!this._updatingHandles?.updating&&!this.isUpdating())}get updatingProgress(){return this.updating?0:1}get updateSuspended(){return this.suspended}get visible(){return!0===this.layer?.visible}set visible(e){this._overrideIfSome("visible",e)}get visibleAtCurrentScale(){return!0}get visibleAtCurrentTimeExtent(){const e=this.view.timeExtent,t=this.layer?.visibilityTimeExtent;return!e||!t||!e.intersection(t).isEmpty}canResume(){const e=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return this.visible&&this.layer?.loaded&&!this.parent?.suspended&&this.view?.ready&&(0,p.Cy)(e)&&this.visibleAtCurrentScale&&this.visibleAtCurrentTimeExtent||!1}getSuspendInfo(){const e=this.parent?.suspended?this.parent.suspendInfo:{};this.view?.ready||(e.viewNotReady=!0),this.layer&&this.layer.loaded||(e.layerNotLoaded=!0);const t=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return(0,p.Cy)(t)&&this.visibleAtCurrentScale||(e.outsideScaleRange=!0),this.visibleAtCurrentTimeExtent||(e.outsideVisibilityTimeExtent=!0),this.visible||(e.layerInvisible=!0),e}isUpdating(){return!1}};(0,a._)([(0,c.Cb)()],_.prototype,"view",void 0),(0,a._)([(0,c.Cb)()],_.prototype,"fullOpacity",null),(0,a._)([(0,c.Cb)()],_.prototype,"layer",void 0),(0,a._)([(0,c.Cb)()],_.prototype,"parent",void 0),(0,a._)([(0,c.Cb)({readOnly:!0})],_.prototype,"suspended",null),(0,a._)([(0,c.Cb)({readOnly:!0})],_.prototype,"suspendInfo",null),(0,a._)([(0,c.Cb)({readOnly:!0})],_.prototype,"legendEnabled",null),(0,a._)([(0,c.Cb)({type:Boolean,readOnly:!0})],_.prototype,"updating",null),(0,a._)([(0,c.Cb)({readOnly:!0})],_.prototype,"updatingProgress",null),(0,a._)([(0,c.Cb)()],_.prototype,"updateSuspended",null),(0,a._)([(0,c.Cb)()],_.prototype,"visible",null),(0,a._)([(0,c.Cb)({readOnly:!0})],_.prototype,"visibleAtCurrentScale",null),(0,a._)([(0,c.Cb)({readOnly:!0})],_.prototype,"visibleAtCurrentTimeExtent",null),_=(0,a._)([(0,u.j)("esri.views.layers.LayerView")],_);const f=_}}]);
//# sourceMappingURL=9597.841f3aef.chunk.js.map