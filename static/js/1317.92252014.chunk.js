"use strict";(self.webpackChunksc_utility=self.webpackChunksc_utility||[]).push([[1317],{83609:(e,t,n)=>{n.d(t,{L:()=>Z,b:()=>H});var r,i,a,s,o,c,l,p,d,h,v,u,m,T,f,S,g=n(30168),P=n(2522),_=n(37081),O=n(33280),A=n(48353),y=n(137),E=n(40526),R=n(74876),w=n(116),I=n(78980),x=n(41012),N=n(82999),z=n(95276),D=n(58406),C=n(98634),L=n(8654),b=n(64201),k=n(19253),U=n(4760),W=n(33720),M=n(53178);function H(e){const t=new b.kG,n=e.terrainDepthTest&&e.output===_.H_.Color,H=e.space===W.I9.World;t.include(A.U,e),t.include(E.Q,e);const{vertex:Z,fragment:j}=t;return j.include(I.n),(0,x.Sv)(Z,e),t.attributes.add(U.T.POSITION,"vec3"),t.attributes.add(U.T.PREVPOSITION,"vec3"),t.attributes.add(U.T.UV0,"vec2"),t.varyings.add("vColor","vec4"),t.varyings.add("vpos","vec3"),t.varyings.add("vUV","vec2"),t.varyings.add("vSize","float"),n&&t.varyings.add("depth","float"),e.hasTip&&t.varyings.add("vLineWidth","float"),Z.uniforms.add(new N.A("nearFar",((e,t)=>t.camera.nearFar)),new z.N("viewport",((e,t)=>t.camera.fullViewport))),Z.code.add((0,C.H)(r||(r=(0,g.Z)(["vec4 projectAndScale(vec4 pos) {\nvec4 posNdc = proj * pos;\nposNdc.xy *= viewport.zw / posNdc.w;\nreturn posNdc;\n}"])))),Z.code.add((0,C.H)(i||(i=(0,g.Z)(["void clip(vec4 pos, inout vec4 prev) {\nfloat vnp = nearFar[0] * 0.99;\nif (prev.z > -nearFar[0]) {\nfloat interpolation = (-vnp - pos.z) / (prev.z - pos.z);\nprev = mix(pos, prev, interpolation);\n}\n}"])))),H?(t.attributes.add(U.T.NORMAL,"vec3"),(0,x._8)(Z),Z.constants.add("tiltThreshold","float",.7),Z.code.add((0,C.H)(a||(a=(0,g.Z)(["vec3 perpendicular(vec3 v) {\nvec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;\nvec3 n2 = cross(v, n);\nvec3 forward = vec3(0.0, 0.0, 1.0);\nfloat tiltDot = dot(forward, n);\nreturn abs(tiltDot) < tiltThreshold ? n : n2;\n}"]))))):Z.code.add((0,C.H)(s||(s=(0,g.Z)(["vec2 perpendicular(vec2 v) {\nreturn vec2(v.y, -v.x);\n}"])))),Z.code.add((0,C.H)(o||(o=(0,g.Z)(["\n      #define vecN ","\n\n      vecN normalizedSegment(vecN pos, vecN prev) {\n        vecN segment = pos - prev;\n        float segmentLen = length(segment);\n\n        // normalize or zero if too short\n        return (segmentLen > 0.001) ? segment / segmentLen : ",";\n      }\n\n      vecN displace(vecN pos, vecN prev, float displacementLen) {\n        vecN segment = normalizedSegment(pos, prev);\n\n        vecN displacementDirU = perpendicular(segment);\n        vecN displacementDirV = segment;\n\n        ","\n\n        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);\n      }\n    "])),H?"vec3":"vec2",H?"vec3(0.0, 0.0, 0.0)":"vec2(0.0, 0.0)",e.anchor===W.i5.Tip?"pos -= 0.5 * displacementLen * displacementDirV;":"")),e.space===W.I9.Screen&&(Z.uniforms.add(new L.g("inverseProjectionMatrix",((e,t)=>t.camera.inverseProjectionMatrix))),Z.code.add((0,C.H)(c||(c=(0,g.Z)(["vec3 inverseProject(vec4 posScreen) {\nposScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;\nreturn (inverseProjectionMatrix * posScreen).xyz;\n}"])))),Z.code.add((0,C.H)(l||(l=(0,g.Z)(["bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {\nfloat cos = dot(rayDir, planeNormal);\nfloat t = dot(planeOrigin, planeNormal) / cos;\nintersection = t * rayDir;\nreturn abs(cos) > 0.001 && t > 0.0;\n}"])))),Z.uniforms.add(new D.p("perScreenPixelRatio",((e,t)=>t.camera.perScreenPixelRatio))),Z.code.add((0,C.H)(p||(p=(0,g.Z)(["\n      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {\n        // Project displaced position back to camera space\n        vec3 displacedPos = inverseProject(displacedPosScreen);\n\n        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally\n        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).\n        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));\n        vec3 planeOrigin = posLeft;\n\n        ",";\n\n        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the\n        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.\n        float offset = lineWidth * perScreenPixelRatio;\n        planeOrigin *= (1.0 - offset);\n\n        // Intersect camera ray with the plane and make sure it is within clip space\n        vec3 rayDir = normalize(displacedPos);\n        vec3 intersection;\n        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {\n          return vec4(intersection.xyz, 1.0);\n        }\n\n        // Fallback: use depth of pos or prev, whichever is closer to the camera\n        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);\n        displacedPos *= minDepth / length(displacedPos);\n        return vec4(displacedPos.xyz, 1.0);\n      }\n  "])),e.hasCap?"\n                if(prev.z > posLeft.z) {\n                  vec2 diff = posLeft.xy - posRight.xy;\n                  planeOrigin.xy += perpendicular(diff) / 2.0;\n                }\n              ":""))),(0,x.ZI)(Z),Z.main.add((0,C.H)(d||(d=(0,g.Z)(["\n    // Check for special value of uv0.y which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just\n    // project outside of clip space.\n    if (uv0.y == 0.0) {\n      // Project out of clip space\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n    else {\n      float lineWidth = getLineWidth();\n      float screenMarkerSize = getScreenMarkerSize();\n\n      vec4 pos  = view * vec4(position, 1.0);\n      vec4 prev = view * vec4(prevPosition, 1.0);\n      clip(pos, prev);\n\n      ","\n\n      ","\n\n      // Convert back into NDC\n      displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;\n\n      // Convert texture coordinate into [0,1]\n      vUV = (uv0 + 1.0) / 2.0;\n      ","\n      ","\n\n      vSize = screenMarkerSize;\n      vColor = getColor();\n\n      // Use camera space for slicing\n      vpos = pos.xyz;\n\n      gl_Position = displacedPosScreen;\n    }"])),H?(0,C.H)(h||(h=(0,g.Z)(["","\n            pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));\n            vec4 displacedPosScreen = projectAndScale(pos);"])),e.hideOnShortSegments?(0,C.H)(v||(v=(0,g.Z)(["\n                  if (areWorldMarkersHidden(pos, prev)) {\n                    // Project out of clip space\n                    gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n                    return;\n                  }"]))):""):(0,C.H)(u||(u=(0,g.Z)(["\n            vec4 posScreen = projectAndScale(pos);\n            vec4 prevScreen = projectAndScale(prev);\n            vec4 displacedPosScreen = posScreen;\n\n            displacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);\n            ",""])),e.space===W.I9.Screen?(0,C.H)(m||(m=(0,g.Z)(["\n                vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));\n\n                // We need three points of the ribbon line in camera space to calculate the plane it lies in\n                // Note that we approximate the third point, since we have no information about the join around prev\n                vec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));\n                vec3 lineLeft = pos.xyz + (pos.xyz - lineRight);\n\n                pos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);\n                displacedPosScreen = projectAndScale(pos);"]))):""),n?"depth = pos.z;":"",H?"":"vUV *= displacedPosScreen.w;",e.hasTip?"vLineWidth = lineWidth;":"")),n&&t.include(R.H,e),t.include(O.f5,e),t.include(M.j,e),j.uniforms.add(new z.N("intrinsicColor",(e=>e.color)),new k.A("tex",(e=>e.markerTexture))),j.include(w.Y),j.constants.add("texelSize","float",1/P.OJ),j.code.add((0,C.H)(T||(T=(0,g.Z)(["float markerAlpha(vec2 samplePos) {\nsamplePos += vec2(0.5, -0.5) * texelSize;\nfloat sdf = rgba2float(texture(tex, samplePos)) - 0.5;\nfloat distance = sdf * vSize;\ndistance -= 0.5;\nreturn clamp(0.5 - distance, 0.0, 1.0);\n}"])))),e.hasTip&&j.constants.add("relativeMarkerSize","float",P.qO/P.OJ).constants.add("relativeTipLineWidth","float",P.zA).code.add((0,C.H)(f||(f=(0,g.Z)(["\n    float tipAlpha(vec2 samplePos) {\n      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker\n      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);\n      samplePos *= vSize;\n\n      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;\n      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);\n\n      ","\n\n      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);\n      return clamp(0.5 - distance, 0.0, 1.0);\n    }\n  "])),H?"halfTipLineWidth *= fwidth(samplePos.y);":"")),t.include(y.b,e),j.main.add((0,C.H)(S||(S=(0,g.Z)(["\n    discardBySlice(vpos);\n    ","\n\n    vec4 finalColor = intrinsicColor * vColor;\n    ","\n    ","\n    outputColorHighlightOID(finalColor, vpos);"])),n?"terrainDepthTest(depth);":"",H?"vec2 samplePos = vUV;":"vec2 samplePos = vUV * gl_FragCoord.w;",e.hasTip?"finalColor.a *= max(markerAlpha(samplePos), tipAlpha(samplePos));":"finalColor.a *= markerAlpha(samplePos);")),t}const Z=Object.freeze(Object.defineProperty({__proto__:null,build:H},Symbol.toStringTag,{value:"Module"}))},21317:(e,t,n)=>{n.d(t,{X:()=>y});var r=n(32035),i=n(12400),a=n(55158),s=n(37081),o=n(26461),c=n(17363),l=n(56529),p=n(93822),d=n(4760),h=n(65964),v=n(82144),u=n(78914),m=n(78041),T=n(50411),f=n(83609),S=n(33720),g=n(8548),P=n(36207);class _ extends u.A{constructor(e,t,r){super(e,t,new v.J(f.L,(()=>n.e(5085).then(n.bind(n,22668)))),r,O)}_makePipelineState(e,t){const{output:n,oitPass:r,space:i,hasOccludees:a}=e;return(0,P.sm)({blending:n===s.H_.Color?(0,m.Wo)(r):null,depthTest:i===S.I9.Draped?null:{func:(0,m.Bh)(r)},depthWrite:(0,m.W$)(e),drawBuffers:n===s.H_.Depth?{buffers:[g.Xg.NONE]}:(0,m.u_)(r,n),colorWrite:P.gf,stencilWrite:a?T.s3:null,stencilTest:a?t?T.eD:T.RY:null,polygonOffset:{factor:0,units:-10}})}initializePipeline(e){return e.occluder?(this._occluderPipelineTransparent=(0,P.sm)({blending:P.Dh,depthTest:T.zV,depthWrite:null,colorWrite:P.gf,stencilWrite:null,stencilTest:T.YD}),this._occluderPipelineOpaque=(0,P.sm)({blending:P.Dh,depthTest:T.zV,depthWrite:null,colorWrite:P.gf,stencilWrite:T.P7,stencilTest:T.ii}),this._occluderPipelineMaskWrite=(0,P.sm)({blending:null,depthTest:T.JN,depthWrite:null,colorWrite:null,stencilWrite:T.s3,stencilTest:T.eD})):this._occluderPipelineTransparent=this._occluderPipelineOpaque=this._occluderPipelineMaskWrite=null,this._occludeePipelineState=this._makePipelineState(e,!0),this._makePipelineState(e,!1)}getPipeline(e,t){var n,r,i;return e?this._occludeePipelineState:t===p.r.TRANSPARENT_OCCLUDER_MATERIAL?null!==(n=this._occluderPipelineTransparent)&&void 0!==n?n:super.getPipeline():t===p.r.OCCLUDER_MATERIAL?null!==(r=this._occluderPipelineOpaque)&&void 0!==r?r:super.getPipeline():null!==(i=this._occluderPipelineMaskWrite)&&void 0!==i?i:super.getPipeline()}}const O=new Map([[d.T.POSITION,0],[d.T.PREVPOSITION,1],[d.T.UV0,2],[d.T.NORMAL,3],[d.T.COLOR,4],[d.T.COLORFEATUREATTRIBUTE,4],[d.T.SIZE,5],[d.T.SIZEFEATUREATTRIBUTE,5],[d.T.OPACITYFEATUREATTRIBUTE,6]]);var A=n(737);class y extends l.F5{constructor(e){super(e,R),this._configuration=new S.PI,this.vertexAttributeLocations=O,this.produces=new Map([[p.r.OPAQUE_MATERIAL,e=>e===s.H_.Highlight||(0,s.D5)(e)&&this.parameters.renderOccluded===l.yD.OccludeAndTransparentStencil],[p.r.OPAQUE_MATERIAL_WITHOUT_NORMALS,e=>(0,s.BX)(e)],[p.r.OCCLUDER_MATERIAL,e=>(0,s.Xo)(e)&&this.parameters.renderOccluded===l.yD.OccludeAndTransparentStencil],[p.r.TRANSPARENT_OCCLUDER_MATERIAL,e=>(0,s.Xo)(e)&&this.parameters.renderOccluded===l.yD.OccludeAndTransparentStencil],[p.r.TRANSPARENT_MATERIAL,e=>(0,s.D5)(e)&&this.parameters.writeDepth],[p.r.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,e=>(0,s.D5)(e)&&!this.parameters.writeDepth],[p.r.DRAPED_MATERIAL,e=>e===s.H_.Color||e===s.H_.Highlight]]),this._layout=this.createLayout()}getConfiguration(e,t){return this._configuration.output=e,this._configuration.space=t.slot===p.r.DRAPED_MATERIAL?S.I9.Draped:this.parameters.worldSpace?S.I9.World:S.I9.Screen,this._configuration.hideOnShortSegments=this.parameters.hideOnShortSegments,this._configuration.hasCap=this.parameters.cap!==A.R.BUTT,this._configuration.anchor=this.parameters.anchor,this._configuration.hasTip=this.parameters.hasTip,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=t.hasOccludees,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.vvOpacity=!!this.parameters.vvOpacity,this._configuration.occluder=this.parameters.renderOccluded===l.yD.OccludeAndTransparentStencil,this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}get visible(){return this.parameters.color[3]>=o.e}intersect(){}createLayout(){const e=(0,a.U$)().vec3f(d.T.POSITION).vec3f(d.T.PREVPOSITION).vec2f(d.T.UV0);return this.parameters.worldSpace&&e.vec3f(d.T.NORMAL),this.parameters.vvSize?e.f32(d.T.SIZEFEATUREATTRIBUTE):e.f32(d.T.SIZE),this.parameters.vvColor?e.f32(d.T.COLORFEATUREATTRIBUTE):e.vec4f(d.T.COLOR),this.parameters.vvOpacity&&e.f32(d.T.OPACITYFEATUREATTRIBUTE),e}createBufferWriter(){return new w(this._layout,this.parameters)}createGLMaterial(e){return new E(e)}}class E extends c.Fj{constructor(){super(...arguments),this._markerPrimitive=null}dispose(){super.dispose(),this._markerTextures.release(this._markerPrimitive),this._markerPrimitive=null}beginSlot(e){const t=this._material.parameters.markerPrimitive;return t!==this._markerPrimitive&&(this._material.setParameters({markerTexture:this._markerTextures.swap(t,this._markerPrimitive)}),this._markerPrimitive=t),this._material.setParameters(this.textureBindParameters),this.acquireTechnique(_,e)}}class R extends h.n{constructor(){super(...arguments),this.width=0,this.color=[1,1,1,1],this.markerPrimitive="arrow",this.placement="end",this.cap=A.R.BUTT,this.anchor=S.i5.Center,this.hasTip=!1,this.worldSpace=!1,this.hideOnShortSegments=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.markerTexture=null}}class w{constructor(e,t){this.vertexBufferLayout=e,this._parameters=t}elementCount(){return"begin-end"===this._parameters.placement?12:6}write(e,t,n,i,a,s){const o=n.get(d.T.POSITION).data,c=o.length/3;let l=[1,0,0];const p=n.get(d.T.NORMAL);this._parameters.worldSpace&&null!=p&&(l=p.data);let h=1,v=0;this._parameters.vvSize?v=n.get(d.T.SIZEFEATUREATTRIBUTE).data[0]:n.has(d.T.SIZE)&&(h=n.get(d.T.SIZE).data[0]);let u=[1,1,1,1],m=0;this._parameters.vvColor?m=n.get(d.T.COLORFEATUREATTRIBUTE).data[0]:n.has(d.T.COLOR)&&(u=n.get(d.T.COLOR).data);let T=0;this._parameters.vvOpacity&&(T=n.get(d.T.OPACITYFEATUREATTRIBUTE).data[0]);const f=new Float32Array(a.buffer);let S=s*(this.vertexBufferLayout.stride/4);const g=(e,t,n,r)=>{if(f[S++]=e[0],f[S++]=e[1],f[S++]=e[2],f[S++]=t[0],f[S++]=t[1],f[S++]=t[2],f[S++]=n[0],f[S++]=n[1],this._parameters.worldSpace&&(f[S++]=l[0],f[S++]=l[1],f[S++]=l[2]),this._parameters.vvSize?f[S++]=v:f[S++]=h,this._parameters.vvColor)f[S++]=m;else{const e=Math.min(4*r,u.length-4);f[S++]=u[e],f[S++]=u[e+1],f[S++]=u[e+2],f[S++]=u[e+3]}this._parameters.vvOpacity&&(f[S++]=T)};let P;var _;(_=P||(P={}))[_.ASCENDING=1]="ASCENDING",_[_.DESCENDING=-1]="DESCENDING";const O=(t,n)=>{const i=(0,r.i)(I,o[3*t],o[3*t+1],o[3*t+2]),a=x;let s=t+n;do{(0,r.i)(a,o[3*s],o[3*s+1],o[3*s+2]),s+=n}while((0,r.H)(i,a)&&s>=0&&s<c);e&&((0,r.t)(i,i,e),(0,r.t)(a,a,e)),g(i,a,[-1,-1],t),g(i,a,[1,-1],t),g(i,a,[1,1],t),g(i,a,[-1,-1],t),g(i,a,[1,1],t),g(i,a,[-1,1],t)},A=this._parameters.placement;"begin"!==A&&"begin-end"!==A||O(0,P.ASCENDING),"end"!==A&&"begin-end"!==A||O(c-1,P.DESCENDING)}}const I=(0,i.Ue)(),x=(0,i.Ue)()}}]);
//# sourceMappingURL=1317.92252014.chunk.js.map